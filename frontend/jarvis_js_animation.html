<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JARVIS Vision Interface</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: black;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let w, h;
function resize() {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// Color definitions
const COLORS = {
  idle: [135, 115, 178],       // CYAN
  listening: [255, 165, 0],  // ORANGE
  answering: [0, 219, 0]     // GREEN
};

// State machine
const STATES = ["idle", "listening", "answering"];
let currentStateIndex = 0;
let currentState = STATES[currentStateIndex];
let currentColor = [...COLORS[currentState]];
let targetColor = [...COLORS[currentState]];

const colorSpeed = 4;
function blendColor(current, target, speed) {
  for (let i = 0; i < 3; i++) {
    const diff = target[i] - current[i];
    if (Math.abs(diff) > speed) {
      current[i] += speed * Math.sign(diff);
    } else {
      current[i] = target[i];
    }
  }
}

const center = { x: () => w/2, y: () => h/2 };
let particles = [];
const numParticles = 100;
let angle = 0;
let pulse = 3;
let pulseDirection = 0.05;

for (let i = 0; i < numParticles; i++) {
  particles.push({
    x: Math.random() * w,
    y: Math.random() * h,
    dx: (Math.random() - 0.5) * 4,
    dy: (Math.random() - 0.5) * 4,
    angleOffset: (i / numParticles) * Math.PI * 2
  });
}

// Toggle state on Enter
window.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    currentStateIndex = (currentStateIndex + 1) % STATES.length;
    currentState = STATES[currentStateIndex];
    targetColor = [...COLORS[currentState]];
  }
});

// Animate
function draw() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
  ctx.fillRect(0, 0, w, h);

  blendColor(currentColor, targetColor, colorSpeed);
  const colorStr = `rgb(${currentColor.map(Math.floor).join(',')})`;

  angle += 0.01;
  pulse += pulseDirection;
  if (pulse > 5 || pulse < 2) pulseDirection *= -1;

  for (let i = 0; i < particles.length; i++) {
    const p = particles[i];

    if (currentState !== "idle") {
      const r = Math.min(w, h) / 3;
      const targetX = center.x() + Math.cos(angle + p.angleOffset) * r;
      const targetY = center.y() + Math.sin(angle + p.angleOffset) * r;
      p.x += (targetX - p.x) * 0.05;
      p.y += (targetY - p.y) * 0.05;
    } else {
      p.x += p.dx;
      p.y += p.dy;
      if (p.x <= 0 || p.x >= w) p.dx *= -1;
      if (p.y <= 0 || p.y >= h) p.dy *= -1;
    }

    ctx.beginPath();
    ctx.fillStyle = colorStr;
    ctx.arc(p.x, p.y, pulse, 0, Math.PI * 2);
    ctx.fill();
  }

  // Text UI
  ctx.fillStyle = 'white';
  ctx.font = '24px sans-serif';
  ctx.fillText('Vision Interface', 20, 40);

  ctx.font = '16px sans-serif';
  ctx.fillText(`System Status: ${currentState.toUpperCase()}`, 20, 70);

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
